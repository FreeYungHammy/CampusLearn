<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CampusLearnâ„¢ Video Call</title>
    <style>
        :root {
            --primary: #3498db;
            --primary-dark: #2980b9;
            --secondary: #2ecc71;
            --danger: #e74c3c;
            --warning: #f39c12;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --gray: #95a5a6;
            --light-gray: #f5f7f9;
            --white: #ffffff;
            --border: #dfe6e9;
            --forum-bg: #f8f9fa;
            --bg-primary: #ffffff;
            --message-sent: #3498db;
            --message-received: #e3f2fd;
            --card-shadow: 0 10px 20px rgba(0,0,0,.08);
            --elev-1: 0 6px 18px rgba(0,0,0,.08);
            --elev-2: 0 12px 28px rgba(0,0,0,.12);
            --transition: all .25s ease;
            --border-radius: 12px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --radius-full: 999px;
        }

        [data-theme="dark"] {
            --light: #2c3e50;
            --light-gray: #34495e;
            --white: #2c3e50;
            --border: #34495e;
            --forum-bg: #2c3e50;
            --bg-primary: #34495e;
            --message-received: #3498db33;
            --dark: #ecf0f1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-primary);
            color: var(--dark);
            line-height: 1.5;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background-color: var(--white);
            border-bottom: 1px solid var(--border);
            box-shadow: var(--elev-1);
            z-index: 100;
            position: sticky;
            top: 0;
        }

        .breadcrumb {
            font-size: 14px;
            color: var(--gray);
        }

        .breadcrumb strong {
            color: var(--primary);
        }

        .call-timer {
            font-size: 16px;
            font-weight: 600;
            color: var(--dark);
        }

        .network-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .network-pill {
            padding: 4px 10px;
            border-radius: var(--radius-full);
            background-color: var(--light-gray);
            font-size: 12px;
            font-weight: 500;
            color: var(--dark);
        }

        .network-pill.p2p {
            background-color: var(--secondary);
            color: white;
        }

        .network-pill.relay {
            background-color: var(--warning);
            color: white;
        }

        .network-pill.unknown {
            background-color: var(--gray);
            color: white;
        }

        .quality-indicator {
            display: flex;
            gap: 2px;
        }

        .quality-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: var(--gray);
        }

        .quality-dot.active {
            background-color: var(--secondary);
        }

        /* Stage */
        .stage {
            flex: 1;
            position: relative;
            background-color: var(--light-gray);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            background-color: var(--dark);
        }

        .local-video {
            position: absolute;
            width: 220px;
            height: 124px;
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            background-color: var(--dark);
            object-fit: cover;
            cursor: move;
            z-index: 10;
            bottom: 20px;
            right: 20px;
            transition: var(--transition);
        }

        .local-video.mirror {
            transform: scaleX(-1);
        }

        /* Control Dock */
        .control-dock {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 16px 24px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-full);
            box-shadow: var(--elev-2);
            z-index: 50;
            transition: var(--transition);
        }

        .control-dock.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .control-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--white);
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: var(--transition);
            position: relative;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn.primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        }

        .control-btn.primary svg {
            fill: var(--white);
        }

        .control-btn.secondary {
            background: var(--white);
            border: 1px solid var(--primary);
        }

        .control-btn.secondary svg {
            fill: var(--primary);
        }

        .control-btn.danger {
            background: var(--danger);
        }

        .control-btn.danger svg {
            fill: var(--white);
        }

        .control-btn.active {
            background: var(--secondary);
        }

        .control-btn.active svg {
            fill: var(--white);
        }

        .control-btn.muted {
            background: var(--gray);
        }

        .control-btn.muted svg {
            fill: var(--white);
        }

        .tooltip {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--dark);
            color: var(--white);
            padding: 4px 8px;
            border-radius: var(--radius-md);
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: var(--transition);
        }

        .control-btn:hover .tooltip {
            opacity: 1;
        }

        /* Slide-over Panel */
        .slide-over {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--white);
            box-shadow: var(--elev-2);
            z-index: 200;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .slide-over.open {
            right: 0;
        }

        .slide-over-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .slide-over-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--dark);
        }

        .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            transition: var(--transition);
        }

        .close-btn:hover {
            background: var(--light-gray);
        }

        .device-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .device-item {
            padding: 12px 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
        }

        .device-item:hover {
            background: var(--light-gray);
        }

        .device-item.active {
            border-color: var(--primary);
            background: var(--message-received);
        }

        .device-name {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .device-id {
            font-size: 12px;
            color: var(--gray);
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Modal */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            opacity: 0;
            pointer-events: none;
            transition: var(--transition);
        }

        .modal-backdrop.open {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--elev-2);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--dark);
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--dark);
        }

        .textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            resize: vertical;
            min-height: 120px;
            font-family: monospace;
            font-size: 14px;
        }

        .textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .hint {
            background: var(--light-gray);
            padding: 12px 16px;
            border-radius: var(--radius-md);
            font-size: 14px;
            color: var(--dark);
            margin-top: 20px;
        }

        .hint-title {
            font-weight: 600;
            margin-bottom: 8px;
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border-radius: var(--radius-md);
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:focus {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
        }

        .btn-primary:hover {
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-secondary {
            background: var(--white);
            color: var(--primary);
            border: 1px solid var(--primary);
        }

        .btn-secondary:hover {
            background: var(--light-gray);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        /* Banners & Toasts */
        .banner {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: var(--radius-md);
            background: var(--warning);
            color: white;
            z-index: 150;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: var(--elev-1);
            max-width: 90%;
        }

        .banner.error {
            background: var(--danger);
        }

        .banner.success {
            background: var(--secondary);
        }

        .banner.hidden {
            display: none;
        }

        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: var(--radius-md);
            background: var(--dark);
            color: white;
            z-index: 150;
            box-shadow: var(--elev-1);
            transition: var(--transition);
            opacity: 0;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .local-video {
                width: 120px;
                height: 68px;
                bottom: 10px;
                right: 10px;
            }

            .control-dock {
                bottom: 10px;
                padding: 12px 16px;
            }

            .control-btn {
                width: 44px;
                height: 44px;
            }

            .slide-over {
                width: 100%;
                right: -100%;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 10px 15px;
            }

            .breadcrumb {
                font-size: 12px;
            }

            .call-timer {
                font-size: 14px;
            }

            .network-pill {
                font-size: 10px;
                padding: 3px 8px;
            }

            .control-dock {
                gap: 8px;
                padding: 10px 14px;
            }

            .control-btn {
                width: 40px;
                height: 40px;
            }
        }

        /* Utility classes */
        .hidden {
            display: none !important;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="breadcrumb">CampusLearn / <strong>Video call</strong></div>
        <div class="call-timer">00:00</div>
        <div class="network-status">
            <div class="network-pill unknown">UNKNOWN</div>
            <div class="quality-indicator">
                <div class="quality-dot"></div>
                <div class="quality-dot"></div>
                <div class="quality-dot"></div>
            </div>
        </div>
    </header>

    <!-- Stage -->
    <main class="stage">
        <video class="remote-video" autoplay playsinline></video>
        <video class="local-video mirror" autoplay muted playsinline></video>
        
        <!-- Control Dock -->
        <div class="control-dock">
            <button class="control-btn primary" id="mic-toggle" aria-label="Toggle microphone">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                </svg>
                <span class="tooltip">Mute (M)</span>
            </button>
            <button class="control-btn primary" id="cam-toggle" aria-label="Toggle camera">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
                </svg>
                <span class="tooltip">Video (V)</span>
            </button>
            <button class="control-btn secondary" id="screenshare" aria-label="Share screen">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M20 18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2H1c-.55 0-1 .45-1 1s.45 1 1 1h22c.55 0 1-.45 1-1s-.45-1-1-1h-3zm-7-3.53v-2.19c-2.78 0-4.61.85-6 2.72.56-2.67 2.11-5.33 6-5.87V7l4 3.73-4 3.74z"/>
                </svg>
                <span class="tooltip">Share (S)</span>
            </button>
            <button class="control-btn secondary" id="device-picker" aria-label="Device settings">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.82,11.69,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                </svg>
                <span class="tooltip">Devices (D)</span>
            </button>
            <button class="control-btn secondary" id="copy-link" aria-label="Copy call link">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                </svg>
                <span class="tooltip">Copy Link</span>
            </button>
            <button class="control-btn secondary" id="manual-pairing" aria-label="Manual pairing">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/>
                </svg>
                <span class="tooltip">Manual Pairing</span>
            </button>
            <button class="control-btn danger" id="leave-call" aria-label="Leave call">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
                <span class="tooltip">Leave (L)</span>
            </button>
        </div>
    </main>

    <!-- Slide-over Panel -->
    <aside class="slide-over" id="device-panel">
        <div class="slide-over-header">
            <h2 class="slide-over-title">Device Settings</h2>
            <button class="close-btn" id="close-device-panel" aria-label="Close device panel">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
            </button>
        </div>
        <div class="device-list">
            <h3>Cameras</h3>
            <div id="camera-list"></div>
            <h3>Microphones</h3>
            <div id="microphone-list"></div>
        </div>
    </aside>

    <!-- Modal -->
    <div class="modal-backdrop" id="manual-pairing-modal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Manual Copy-Paste Signaling</h2>
                <button class="close-btn" id="close-manual-modal" aria-label="Close modal">
                    <svg width="20" height="20" viewBox="0 0 24 24">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="local-sdp" class="form-label">Your Offer/Answer</label>
                    <textarea id="local-sdp" class="textarea" placeholder="Your SDP will appear here..." readonly></textarea>
                </div>
                <div class="form-group">
                    <label for="remote-sdp" class="form-label">Paste Remote SDP/ICE</label>
                    <textarea id="remote-sdp" class="textarea" placeholder="Paste remote SDP or ICE candidate here..."></textarea>
                </div>
                <div class="hint">
                    <div class="hint-title">How it works:</div>
                    <ol>
                        <li>Click "Create Offer" to generate an SDP offer</li>
                        <li>Copy the text from "Your Offer/Answer" and send it to your peer</li>
                        <li>Paste the peer's SDP answer into "Paste Remote SDP/ICE" and click "Apply"</li>
                        <li>For ICE candidates, paste them as they arrive and click "Apply"</li>
                    </ol>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="create-offer">Create Offer</button>
                <button class="btn btn-secondary" id="create-answer">Create Answer</button>
                <button class="btn btn-primary" id="apply-remote">Apply</button>
            </div>
        </div>
    </div>

    <!-- Banners & Toasts -->
    <div class="banner hidden" id="permission-banner">
        <svg width="20" height="20" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z" fill="white"/>
        </svg>
        <span>Camera and microphone permissions are required for video calls.</span>
    </div>

    <div class="banner hidden" id="reconnect-banner">
        <svg width="20" height="20" viewBox="0 0 24 24">
            <path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" fill="white"/>
        </svg>
        <span>Connection lost. <button class="btn btn-secondary" id="rejoin-btn" style="margin-left: 10px;">Rejoin</button></span>
    </div>

    <div class="toast" id="copy-toast">Link copied to clipboard!</div>

    <script>
        // Main application class
        class VideoCallApp {
            constructor() {
                this.ui = new UiController(this);
                this.pcManager = new PeerConnectionManager(this);
                this.statsMonitor = new StatsMonitor(this);
                this.signalingAdapter = new ManualSignalingAdapter();
                
                this.localStream = null;
                this.remoteStream = null;
                this.isCallActive = false;
                this.callStartTime = null;
                this.timerInterval = null;
                
                this.init();
            }
            
            async init() {
                try {
                    await this.getUserMedia();
                    this.ui.updateLocalVideo(this.localStream);
                    this.bindEventListeners();
                    this.ui.showToast('Camera and microphone ready');
                } catch (error) {
                    console.error('Error initializing video call:', error);
                    this.ui.showPermissionBanner();
                }
            }
            
            async getUserMedia() {
                const constraints = {
                    audio: true,
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 }, 
                        frameRate: { ideal: 30 } 
                    }
                };
                
                try {
                    this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (error) {
                    throw new Error('Could not access camera and microphone: ' + error.message);
                }
            }
            
            bindEventListeners() {
                // UI event bindings are handled by UiController
                // WebRTC event bindings are handled by PeerConnectionManager
            }
            
            startCall() {
                this.isCallActive = true;
                this.callStartTime = Date.now();
                this.startTimer();
                this.pcManager.createOffer();
            }
            
            joinCall() {
                this.isCallActive = true;
                this.callStartTime = Date.now();
                this.startTimer();
            }
            
            leaveCall() {
                this.isCallActive = false;
                this.stopTimer();
                this.pcManager.close();
                this.ui.updateCallTimer('00:00');
                this.ui.showToast('Call ended');
            }
            
            startTimer() {
                this.stopTimer();
                this.timerInterval = setInterval(() => {
                    if (this.callStartTime) {
                        const elapsed = Math.floor((Date.now() - this.callStartTime) / 1000);
                        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                        const seconds = (elapsed % 60).toString().padStart(2, '0');
                        this.ui.updateCallTimer(`${minutes}:${seconds}`);
                    }
                }, 1000);
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            
            toggleMic() {
                if (this.localStream) {
                    const audioTracks = this.localStream.getAudioTracks();
                    if (audioTracks.length > 0) {
                        const enabled = !audioTracks[0].enabled;
                        audioTracks[0].enabled = enabled;
                        this.ui.updateMicButton(!enabled);
                        return enabled;
                    }
                }
                return false;
            }
            
            toggleCam() {
                if (this.localStream) {
                    const videoTracks = this.localStream.getVideoTracks();
                    if (videoTracks.length > 0) {
                        const enabled = !videoTracks[0].enabled;
                        videoTracks[0].enabled = enabled;
                        this.ui.updateCamButton(!enabled);
                        return enabled;
                    }
                }
                return false;
            }
            
            async toggleScreenShare() {
                return await this.pcManager.toggleScreenShare();
            }
            
            async switchCamera(deviceId) {
                if (this.localStream) {
                    await this.pcManager.switchCamera(deviceId);
                }
            }
            
            async switchMicrophone(deviceId) {
                if (this.localStream) {
                    await this.pcManager.switchMicrophone(deviceId);
                }
            }
            
            updateNetworkStatus(status, quality) {
                this.ui.updateNetworkStatus(status, quality);
            }
        }

        // Peer Connection Manager
        class PeerConnectionManager {
            constructor(app) {
                this.app = app;
                this.pc = null;
                this.localStream = null;
                this.remoteStream = null;
                this.isScreenSharing = false;
                this.videoSender = null;
                this.audioSender = null;
                
                this.init();
            }
            
            init() {
                const config = window.ICE_CONFIG || {
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                };
                
                this.pc = new RTCPeerConnection(config);
                
                // Set up event listeners
                this.pc.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', this.pc.iceConnectionState);
                    this.handleIceConnectionStateChange();
                };
                
                this.pc.onicegatheringstatechange = () => {
                    console.log('ICE gathering state:', this.pc.iceGatheringState);
                };
                
                this.pc.onsignalingstatechange = () => {
                    console.log('Signaling state:', this.pc.signalingState);
                };
                
                this.pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.app.signalingAdapter.send({
                            type: 'ice-candidate',
                            candidate: event.candidate
                        });
                    }
                };
                
                this.pc.ontrack = (event) => {
                    console.log('Received remote track:', event.track.kind);
                    if (!this.remoteStream) {
                        this.remoteStream = new MediaStream();
                    }
                    this.remoteStream.addTrack(event.track);
                    this.app.ui.updateRemoteVideo(this.remoteStream);
                };
            }
            
            async addLocalStream(stream) {
                this.localStream = stream;
                
                // Add audio tracks
                stream.getAudioTracks().forEach(track => {
                    this.audioSender = this.pc.addTrack(track, stream);
                });
                
                // Add video tracks
                stream.getVideoTracks().forEach(track => {
                    this.videoSender = this.pc.addTrack(track, stream);
                });
            }
            
            async createOffer() {
                try {
                    await this.addLocalStream(this.app.localStream);
                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);
                    
                    this.app.signalingAdapter.send({
                        type: 'offer',
                        sdp: offer.sdp
                    });
                    
                    return offer;
                } catch (error) {
                    console.error('Error creating offer:', error);
                    this.app.ui.showToast('Error creating offer');
                }
            }
            
            async createAnswer() {
                try {
                    await this.addLocalStream(this.app.localStream);
                    const answer = await this.pc.createAnswer();
                    await this.pc.setLocalDescription(answer);
                    
                    this.app.signalingAdapter.send({
                        type: 'answer',
                        sdp: answer.sdp
                    });
                    
                    return answer;
                } catch (error) {
                    console.error('Error creating answer:', error);
                    this.app.ui.showToast('Error creating answer');
                }
            }
            
            async setRemoteDescription(description) {
                try {
                    await this.pc.setRemoteDescription(description);
                } catch (error) {
                    console.error('Error setting remote description:', error);
                    this.app.ui.showToast('Error applying remote description');
                }
            }
            
            async addIceCandidate(candidate) {
                try {
                    await this.pc.addIceCandidate(candidate);
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }
            
            async toggleScreenShare() {
                try {
                    if (!this.isScreenSharing) {
                        // Start screen sharing
                        const screenStream = await navigator.mediaDevices.getDisplayMedia({
                            video: true,
                            audio: true
                        });
                        
                        const screenTrack = screenStream.getVideoTracks()[0];
                        
                        // Replace the video track with screen share
                        if (this.videoSender) {
                            await this.videoSender.replaceTrack(screenTrack);
                        }
                        
                        // Handle when user stops screen sharing
                        screenTrack.onended = () => {
                            this.toggleScreenShare();
                        };
                        
                        this.isScreenSharing = true;
                        this.app.ui.updateScreenShareButton(true);
                        return true;
                    } else {
                        // Stop screen sharing and revert to camera
                        const cameraStream = await navigator.mediaDevices.getUserMedia({
                            video: { width: 1280, height: 720, frameRate: 30 }
                        });
                        
                        const cameraTrack = cameraStream.getVideoTracks()[0];
                        
                        // Replace the screen share track with camera
                        if (this.videoSender) {
                            await this.videoSender.replaceTrack(cameraTrack);
                        }
                        
                        // Stop the screen share tracks
                        this.isScreenSharing = false;
                        this.app.ui.updateScreenShareButton(false);
                        return false;
                    }
                } catch (error) {
                    console.error('Error toggling screen share:', error);
                    this.app.ui.showToast('Error sharing screen');
                    return this.isScreenSharing;
                }
            }
            
            async switchCamera(deviceId) {
                try {
                    const constraints = {
                        video: { 
                            deviceId: { exact: deviceId },
                            width: { ideal: 1280 }, 
                            height: { ideal: 720 }, 
                            frameRate: { ideal: 30 } 
                        }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    const newVideoTrack = stream.getVideoTracks()[0];
                    
                    // Replace the current video track
                    if (this.videoSender) {
                        await this.videoSender.replaceTrack(newVideoTrack);
                    }
                    
                    // Update the local stream
                    if (this.app.localStream) {
                        const oldVideoTrack = this.app.localStream.getVideoTracks()[0];
                        this.app.localStream.removeTrack(oldVideoTrack);
                        this.app.localStream.addTrack(newVideoTrack);
                        this.app.ui.updateLocalVideo(this.app.localStream);
                    }
                    
                    // Stop the unused track
                    stream.getTracks().forEach(track => {
                        if (track !== newVideoTrack) {
                            track.stop();
                        }
                    });
                    
                    return true;
                } catch (error) {
                    console.error('Error switching camera:', error);
                    this.app.ui.showToast('Error switching camera');
                    return false;
                }
            }
            
            async switchMicrophone(deviceId) {
                try {
                    const constraints = {
                        audio: { deviceId: { exact: deviceId } }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    const newAudioTrack = stream.getAudioTracks()[0];
                    
                    // Replace the current audio track
                    if (this.audioSender) {
                        await this.audioSender.replaceTrack(newAudioTrack);
                    }
                    
                    // Update the local stream
                    if (this.app.localStream) {
                        const oldAudioTrack = this.app.localStream.getAudioTracks()[0];
                        this.app.localStream.removeTrack(oldAudioTrack);
                        this.app.localStream.addTrack(newAudioTrack);
                    }
                    
                    // Stop the unused track
                    stream.getTracks().forEach(track => {
                        if (track !== newAudioTrack) {
                            track.stop();
                        }
                    });
                    
                    return true;
                } catch (error) {
                    console.error('Error switching microphone:', error);
                    this.app.ui.showToast('Error switching microphone');
                    return false;
                }
            }
            
            handleIceConnectionStateChange() {
                const state = this.pc.iceConnectionState;
                
                if (state === 'connected' || state === 'completed') {
                    this.app.ui.hideReconnectBanner();
                } else if (state === 'disconnected' || state === 'failed') {
                    // Show reconnect banner after 8 seconds
                    setTimeout(() => {
                        if (this.pc.iceConnectionState === 'disconnected' || 
                            this.pc.iceConnectionState === 'failed') {
                            this.app.ui.showReconnectBanner();
                        }
                    }, 8000);
                }
            }
            
            close() {
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }
                
                if (this.remoteStream) {
                    this.remoteStream.getTracks().forEach(track => track.stop());
                    this.remoteStream = null;
                }
                
                this.isScreenSharing = false;
                this.app.ui.updateScreenShareButton(false);
            }
        }

        // UI Controller
        class UiController {
            constructor(app) {
                this.app = app;
                this.dockHideTimeout = null;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                
                this.init();
            }
            
            init() {
                this.bindEventListeners();
                this.setupPiPDrag();
                this.startDockAutoHide();
            }
            
            bindEventListeners() {
                // Control buttons
                document.getElementById('mic-toggle').addEventListener('click', () => {
                    this.app.toggleMic();
                });
                
                document.getElementById('cam-toggle').addEventListener('click', () => {
                    this.app.toggleCam();
                });
                
                document.getElementById('screenshare').addEventListener('click', () => {
                    this.app.toggleScreenShare();
                });
                
                document.getElementById('device-picker').addEventListener('click', () => {
                    this.openDevicePanel();
                });
                
                document.getElementById('copy-link').addEventListener('click', () => {
                    this.copyCallLink();
                });
                
                document.getElementById('manual-pairing').addEventListener('click', () => {
                    this.openManualPairingModal();
                });
                
                document.getElementById('leave-call').addEventListener('click', () => {
                    this.app.leaveCall();
                });
                
                // Panel and modal controls
                document.getElementById('close-device-panel').addEventListener('click', () => {
                    this.closeDevicePanel();
                });
                
                document.getElementById('close-manual-modal').addEventListener('click', () => {
                    this.closeManualPairingModal();
                });
                
                document.getElementById('create-offer').addEventListener('click', () => {
                    this.app.startCall();
                });
                
                document.getElementById('create-answer').addEventListener('click', () => {
                    this.app.joinCall();
                });
                
                document.getElementById('apply-remote').addEventListener('click', () => {
                    this.applyRemoteSdp();
                });
                
                document.getElementById('rejoin-btn').addEventListener('click', () => {
                    this.rejoinCall();
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    this.handleKeyboardShortcuts(e);
                });
                
                // Mouse movement for dock auto-hide
                document.addEventListener('mousemove', () => {
                    this.showDock();
                    this.startDockAutoHide();
                });
                
                document.addEventListener('touchstart', () => {
                    this.showDock();
                    this.startDockAutoHide();
                });
            }
            
            handleKeyboardShortcuts(e) {
                // Only trigger if not focused on input elements
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;
                
                switch(e.key.toLowerCase()) {
                    case 'm':
                        this.app.toggleMic();
                        break;
                    case 'v':
                        this.app.toggleCam();
                        break;
                    case 's':
                        this.app.toggleScreenShare();
                        break;
                    case 'd':
                        this.openDevicePanel();
                        break;
                    case 'l':
                        this.app.leaveCall();
                        break;
                    case '?':
                        this.showKeyboardHelp();
                        break;
                    case 'escape':
                        this.closeDevicePanel();
                        this.closeManualPairingModal();
                        break;
                }
            }
            
            setupPiPDrag() {
                const localVideo = document.querySelector('.local-video');
                
                localVideo.addEventListener('mousedown', (e) => {
                    this.startDrag(e, localVideo);
                });
                
                localVideo.addEventListener('touchstart', (e) => {
                    this.startDrag(e, localVideo);
                });
                
                document.addEventListener('mousemove', (e) => {
                    this.drag(e, localVideo);
                });
                
                document.addEventListener('touchmove', (e) => {
                    this.drag(e, localVideo);
                });
                
                document.addEventListener('mouseup', () => {
                    this.stopDrag(localVideo);
                });
                
                document.addEventListener('touchend', () => {
                    this.stopDrag(localVideo);
                });
            }
            
            startDrag(e, element) {
                this.isDragging = true;
                element.style.transition = 'none';
                
                const rect = element.getBoundingClientRect();
                if (e.type === 'mousedown') {
                    this.dragOffset.x = e.clientX - rect.left;
                    this.dragOffset.y = e.clientY - rect.top;
                } else if (e.type === 'touchstart') {
                    this.dragOffset.x = e.touches[0].clientX - rect.left;
                    this.dragOffset.y = e.touches[0].clientY - rect.top;
                }
                
                e.preventDefault();
            }
            
            drag(e, element) {
                if (!this.isDragging) return;
                
                let clientX, clientY;
                if (e.type === 'mousemove') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else if (e.type === 'touchmove') {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                }
                
                const stage = document.querySelector('.stage');
                const stageRect = stage.getBoundingClientRect();
                
                // Calculate new position
                let newX = clientX - this.dragOffset.x - stageRect.left;
                let newY = clientY - this.dragOffset.y - stageRect.top;
                
                // Constrain within stage bounds
                newX = Math.max(0, Math.min(newX, stageRect.width - element.offsetWidth));
                newY = Math.max(0, Math.min(newY, stageRect.height - element.offsetHeight));
                
                element.style.left = `${newX}px`;
                element.style.top = `${newY}px`;
                
                e.preventDefault();
            }
            
            stopDrag(element) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                element.style.transition = 'var(--transition)';
                
                // Snap to nearest corner
                this.snapToCorner(element);
            }
            
            snapToCorner(element) {
                const stage = document.querySelector('.stage');
                const stageRect = stage.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                const relativeX = elementRect.left - stageRect.left;
                const relativeY = elementRect.top - stageRect.top;
                
                const stageCenterX = stageRect.width / 2;
                const stageCenterY = stageRect.height / 2;
                
                let snapX, snapY;
                
                // Determine which quadrant the element is in
                if (relativeX < stageCenterX) {
                    snapX = 20; // Left side
                } else {
                    snapX = stageRect.width - element.offsetWidth - 20; // Right side
                }
                
                if (relativeY < stageCenterY) {
                    snapY = 20; // Top side
                } else {
                    snapY = stageRect.height - element.offsetHeight - 20; // Bottom side
                }
                
                // Apply snap position
                element.style.left = `${snapX}px`;
                element.style.top = `${snapY}px`;
            }
            
            startDockAutoHide() {
                // Clear existing timeout
                if (this.dockHideTimeout) {
                    clearTimeout(this.dockHideTimeout);
                }
                
                // Set new timeout to hide dock after 3 seconds
                this.dockHideTimeout = setTimeout(() => {
                    this.hideDock();
                }, 3000);
            }
            
            showDock() {
                const dock = document.querySelector('.control-dock');
                dock.classList.remove('hidden');
            }
            
            hideDock() {
                const dock = document.querySelector('.control-dock');
                dock.classList.add('hidden');
            }
            
            updateLocalVideo(stream) {
                const localVideo = document.querySelector('.local-video');
                localVideo.srcObject = stream;
            }
            
            updateRemoteVideo(stream) {
                const remoteVideo = document.querySelector('.remote-video');
                remoteVideo.srcObject = stream;
            }
            
            updateCallTimer(time) {
                document.querySelector('.call-timer').textContent = time;
            }
            
            updateMicButton(muted) {
                const micBtn = document.getElementById('mic-toggle');
                if (muted) {
                    micBtn.classList.add('muted');
                    micBtn.querySelector('.tooltip').textContent = 'Unmute (M)';
                } else {
                    micBtn.classList.remove('muted');
                    micBtn.querySelector('.tooltip').textContent = 'Mute (M)';
                }
            }
            
            updateCamButton(off) {
                const camBtn = document.getElementById('cam-toggle');
                if (off) {
                    camBtn.classList.add('muted');
                    camBtn.querySelector('.tooltip').textContent = 'Enable Video (V)';
                } else {
                    camBtn.classList.remove('muted');
                    camBtn.querySelector('.tooltip').textContent = 'Disable Video (V)';
                }
            }
            
            updateScreenShareButton(active) {
                const shareBtn = document.getElementById('screenshare');
                if (active) {
                    shareBtn.classList.add('active');
                    shareBtn.querySelector('.tooltip').textContent = 'Stop Share (S)';
                } else {
                    shareBtn.classList.remove('active');
                    shareBtn.querySelector('.tooltip').textContent = 'Share Screen (S)';
                }
            }
            
            updateNetworkStatus(status, quality) {
                const pill = document.querySelector('.network-pill');
                const dots = document.querySelectorAll('.quality-dot');
                
                // Update status text and class
                pill.textContent = status;
                pill.className = 'network-pill';
                pill.classList.add(status.toLowerCase());
                
                // Update quality indicator
                dots.forEach((dot, index) => {
                    if (index < quality) {
                        dot.classList.add('active');
                    } else {
                        dot.classList.remove('active');
                    }
                });
            }
            
            async openDevicePanel() {
                const panel = document.getElementById('device-panel');
                panel.classList.add('open');
                
                // Load devices
                await this.loadDevices();
            }
            
            closeDevicePanel() {
                const panel = document.getElementById('device-panel');
                panel.classList.remove('open');
            }
            
            async loadDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const cameras = devices.filter(device => device.kind === 'videoinput');
                    const microphones = devices.filter(device => device.kind === 'audioinput');
                    
                    this.populateDeviceList('camera-list', cameras, 'switchCamera');
                    this.populateDeviceList('microphone-list', microphones, 'switchMicrophone');
                } catch (error) {
                    console.error('Error loading devices:', error);
                }
            }
            
            populateDeviceList(containerId, devices, handler) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                
                devices.forEach(device => {
                    const item = document.createElement('div');
                    item.className = 'device-item';
                    item.innerHTML = `
                        <div class="device-name">${device.label || 'Unknown Device'}</div>
                        <div class="device-id">${device.deviceId}</div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.app[handler](device.deviceId);
                        // Update active state
                        document.querySelectorAll(`#${containerId} .device-item`).forEach(el => {
                            el.classList.remove('active');
                        });
                        item.classList.add('active');
                    });
                    
                    container.appendChild(item);
                });
            }
            
            openManualPairingModal() {
                const modal = document.getElementById('manual-pairing-modal');
                modal.classList.add('open');
            }
            
            closeManualPairingModal() {
                const modal = document.getElementById('manual-pairing-modal');
                modal.classList.remove('open');
            }
            
            applyRemoteSdp() {
                const remoteSdpTextarea = document.getElementById('remote-sdp');
                const remoteData = remoteSdpTextarea.value.trim();
                
                if (!remoteData) {
                    this.showToast('Please paste remote SDP or ICE candidate');
                    return;
                }
                
                try {
                    const data = JSON.parse(atob(remoteData));
                    
                    if (data.type === 'offer') {
                        this.app.pcManager.setRemoteDescription(new RTCSessionDescription(data));
                        this.app.joinCall();
                    } else if (data.type === 'answer') {
                        this.app.pcManager.setRemoteDescription(new RTCSessionDescription(data));
                    } else if (data.type === 'ice-candidate') {
                        this.app.pcManager.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                    
                    this.showToast('Remote data applied successfully');
                } catch (error) {
                    console.error('Error applying remote data:', error);
                    this.showToast('Error applying remote data - invalid format');
                }
            }
            
            copyCallLink() {
                const url = window.location.href;
                navigator.clipboard.writeText(url).then(() => {
                    this.showToast('Call link copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    this.showToast('Failed to copy link');
                });
            }
            
            showPermissionBanner() {
                const banner = document.getElementById('permission-banner');
                banner.classList.remove('hidden');
            }
            
            showReconnectBanner() {
                const banner = document.getElementById('reconnect-banner');
                banner.classList.remove('hidden');
            }
            
            hideReconnectBanner() {
                const banner = document.getElementById('reconnect-banner');
                banner.classList.add('hidden');
            }
            
            showToast(message) {
                const toast = document.getElementById('copy-toast');
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            showKeyboardHelp() {
                // Simple keyboard help - in a real app, this would be a modal
                alert(`Keyboard Shortcuts:
M - Toggle microphone
V - Toggle camera
S - Toggle screen share
D - Open device settings
L - Leave call
? - Show this help
ESC - Close modals/panels`);
            }
            
            rejoinCall() {
                this.hideReconnectBanner();
                // In a real implementation, this would reinitialize the connection
                this.showToast('Attempting to reconnect...');
            }
        }

        // Stats Monitor
        class StatsMonitor {
            constructor(app) {
                this.app = app;
                this.statsInterval = null;
                this.start();
            }
            
            start() {
                // Poll stats every 5 seconds
                this.statsInterval = setInterval(() => {
                    this.getStats();
                }, 5000);
            }
            
            async getStats() {
                if (!this.app.pcManager.pc) return;
                
                try {
                    const stats = await this.app.pcManager.pc.getStats();
                    let connectionType = 'UNKNOWN';
                    let rtt = null;
                    let availableBitrate = null;
                    let packetsLost = null;
                    
                    stats.forEach(report => {
                        if (report.type === 'candidate-pair' && report.nominated) {
                            // Determine connection type
                            const localCandidate = stats.get(report.localCandidateId);
                            const remoteCandidate = stats.get(report.remoteCandidateId);
                            
                            if (localCandidate && remoteCandidate) {
                                if (localCandidate.candidateType === 'host' && remoteCandidate.candidateType === 'host') {
                                    connectionType = 'P2P';
                                } else if (localCandidate.candidateType === 'relay' || remoteCandidate.candidateType === 'relay') {
                                    connectionType = 'RELAY';
                                } else {
                                    connectionType = 'P2P'; // srflx or prflx
                                }
                            }
                            
                            // Get RTT if available
                            if (report.currentRoundTripTime) {
                                rtt = report.currentRoundTripTime * 1000; // Convert to ms
                            }
                            
                            // Get available bitrate
                            if (report.availableOutgoingBitrate) {
                                availableBitrate = report.availableOutgoingBitrate;
                            }
                        }
                        
                        // Get packets lost for video (simplified)
                        if (report.type === 'inbound-rtp' && report.kind === 'video') {
                            packetsLost = report.packetsLost;
                        }
                    });
                    
                    // Calculate quality indicator (0-3)
                    let quality = 3; // Good by default
                    
                    if (rtt && rtt > 300) {
                        quality = 1; // Poor
                    } else if (rtt && rtt > 150) {
                        quality = 2; // Fair
                    }
                    
                    if (packetsLost && packetsLost > 10) {
                        quality = Math.min(quality, 1); // Degrade to poor if packet loss is high
                    }
                    
                    this.app.updateNetworkStatus(connectionType, quality);
                    
                } catch (error) {
                    console.error('Error getting stats:', error);
                }
            }
            
            stop() {
                if (this.statsInterval) {
                    clearInterval(this.statsInterval);
                    this.statsInterval = null;
                }
            }
        }

        // Signaling Adapter (Pluggable interface)
        class SignalingAdapter {
            constructor(mode = 'manual') {
                this.mode = mode;
                this.messageCallbacks = [];
            }
            
            onMessage(callback) {
                this.messageCallbacks.push(callback);
            }
            
            send(data) {
                // To be implemented by specific adapters
                console.log('Signaling send:', data);
            }
            
            join(callId) {
                // To be implemented by specific adapters
            }
            
            leave(callId) {
                // To be implemented by specific adapters
            }
            
            destroy() {
                this.messageCallbacks = [];
            }
        }

        // Manual Signaling Adapter (Copy-Paste)
        class ManualSignalingAdapter extends SignalingAdapter {
            constructor() {
                super('manual');
            }
            
            send(data) {
                super.send(data);
                
                // For manual signaling, update the UI with the data to copy
                const localSdpTextarea = document.getElementById('local-sdp');
                const base64Data = btoa(JSON.stringify(data));
                localSdpTextarea.value = base64Data;
                
                // Notify any listeners (for future extensibility)
                this.messageCallbacks.forEach(callback => {
                    callback(data);
                });
            }
            
            // In a real implementation, we would also handle incoming messages
            // from the manual paste UI, but that's handled by the UiController
        }

        // TODO: Other signaling adapters (WebSocket, REST, etc.)
        // class WebSocketSignalingAdapter extends SignalingAdapter { ... }
        // class RestSignalingAdapter extends SignalingAdapter { ... }
        // class PostMessageSignalingAdapter extends SignalingAdapter { ... }

        // Global initialization
        window.VideoCall = {
            init: function(options = {}) {
                const app = new VideoCallApp();
                return app;
            }
        };

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.videoCallApp = window.VideoCall.init();
        });
    </script>
</body>
</html>