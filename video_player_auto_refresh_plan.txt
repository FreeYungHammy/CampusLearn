Video Player Auto-Refresh After Compression Plan

Problem Summary
After video compression completes and loading reaches 100%, users currently need to manually refresh or go in/out of the video player to see the compressed qualities. We need to implement automatic refresh functionality so users can seamlessly access compressed video qualities without manual intervention.

Current Behavior Analysis
1. Video compression runs in background after upload
2. Frontend polls compression status every 2 seconds
3. When compression completes, status updates to "completed"
4. User must manually refresh or re-enter player to see new qualities
5. No automatic video source refresh occurs

Implementation Plan

Phase 1: Frontend Compression Status Monitoring

1.1 Enhance useVideoCompressionStatus Hook
File: frontend/src/hooks/useVideoCompressionStatus.ts

Changes:
- Add callback mechanism for compression completion
- Implement automatic refresh trigger when compression finishes
- Add quality availability detection

Code to add:
```typescript
interface CompressionStatus {
  compressionStatus: 'pending' | 'compressing' | 'completed' | 'failed';
  compressedQualities: string[];
}

interface UseVideoCompressionStatusReturn {
  compressionStatus: string;
  compressedQualities: string[];
  loading: boolean;
  error: string | null;
  refetch: () => void;
  onCompressionComplete?: () => void; // New callback
}

export const useVideoCompressionStatus = (
  fileId: string | undefined, 
  token: string | undefined,
  onCompressionComplete?: () => void // New parameter
) => {
  const [previousStatus, setPreviousStatus] = useState<string>('pending');
  
  // Detect when compression completes
  useEffect(() => {
    if (previousStatus === 'compressing' && status.compressionStatus === 'completed') {
      console.log('🎬 Compression completed, triggering refresh');
      onCompressionComplete?.();
    }
    setPreviousStatus(status.compressionStatus);
  }, [status.compressionStatus, previousStatus, onCompressionComplete]);

  return {
    ...status,
    loading,
    error,
    refetch: checkStatus,
    onCompressionComplete
  };
};
```

1.2 Update VideoPlayer Component
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Add compression completion callback
- Implement automatic video source refresh
- Add loading state management for quality updates
- Show user feedback during refresh

Code to modify around line 39:
```typescript
const VideoPlayer: React.FC<VideoPlayerProps> = ({
  src,
  title,
  fileId,
  className = "",
  style = {},
}) => {
  // ... existing state
  const [isRefreshingQualities, setIsRefreshingQualities] = useState(false);
  const [compressionJustCompleted, setCompressionJustCompleted] = useState(false);

  // Handle compression completion
  const handleCompressionComplete = useCallback(() => {
    console.log('🎬 Compression completed, refreshing video qualities');
    setIsRefreshingQualities(true);
    setCompressionJustCompleted(true);
    
    // Refresh the video source to pick up new qualities
    setTimeout(() => {
      setIsRefreshingQualities(false);
      setCompressionJustCompleted(false);
      // Trigger quality optimization to pick up new compressed files
      optimizeVideoSource();
    }, 1000); // Small delay to ensure backend has updated
  }, []);

  // Update the hook call
  const { compressionStatus, compressedQualities, loading: statusLoading } = useVideoCompressionStatus(
    fileId || undefined, 
    token || undefined,
    handleCompressionComplete // Pass the callback
  );
```

1.3 Add User Feedback for Compression Completion
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Add toast notification for compression completion
- Show loading indicator during quality refresh
- Update quality selector with new options

Code to add:
```typescript
// Add toast notification
import { toast } from 'react-hot-toast'; // Assuming you have toast notifications

// In handleCompressionComplete function:
const handleCompressionComplete = useCallback(() => {
  console.log('🎬 Compression completed, refreshing video qualities');
  setIsRefreshingQualities(true);
  setCompressionJustCompleted(true);
  
  // Show user notification
  toast.success('Video compression completed! New qualities are now available.', {
    duration: 4000,
    position: 'top-right'
  });
  
  // Refresh the video source
  setTimeout(() => {
    setIsRefreshingQualities(false);
    setCompressionJustCompleted(false);
    optimizeVideoSource();
  }, 1000);
}, []);

// Update available qualities when compression completes
const availableQualities = useMemo(() => {
  if (compressionStatus === 'completed' && compressedQualities.length > 0) {
    return compressedQualities.map(q => ({ name: q, label: q }));
  }
  return [{ name: 'original', label: 'Original' }];
}, [compressionStatus, compressedQualities, compressionJustCompleted]);
```

Phase 2: Backend Compression Status Updates

2.1 Improve Compression Status Webhook
File: backend/src/services/video-compression.service.ts

Changes:
- Add real-time status updates via WebSocket
- Ensure database status is updated immediately when compression completes
- Add compression completion events

Code to add around line 559:
```typescript
private static async updateCompressionStatus(
  bucketPath: string,
  status: "pending" | "compressing" | "completed" | "failed",
  compressedQualities?: string[]
): Promise<void> {
  try {
    const file = await FileModel.findOne({ externalUri: bucketPath });
    if (file) {
      const previousStatus = file.compressionStatus;
      file.compressionStatus = status;
      if (compressedQualities) {
        file.compressedQualities = compressedQualities;
      }
      await file.save();
      
      logger.info(`📊 Updated compression status for ${bucketPath}: ${status}`);
      
      // Emit WebSocket event for real-time updates
      if (status === 'completed' && previousStatus === 'compressing') {
        try {
          const { io } = await import('../socket/socketManager');
          io.emit('video-compression-completed', {
            fileId: file._id.toString(),
            compressedQualities: compressedQualities || []
          });
        } catch (socketError) {
          logger.warn('Failed to emit compression completion event:', socketError);
        }
      }
    }
  } catch (error) {
    logger.error(`❌ Failed to update compression status for ${bucketPath}:`, error);
  }
}
```

2.2 Add WebSocket Event Handler
File: backend/src/socket/socketManager.ts (or wherever your socket logic is)

Changes:
- Add handler for compression completion events
- Broadcast to relevant users

Code to add:
```typescript
// Add compression completion event handler
socket.on('video-compression-completed', (data) => {
  // Broadcast to all users who might be viewing this video
  io.emit('video-compression-update', {
    fileId: data.fileId,
    compressedQualities: data.compressedQualities,
    timestamp: Date.now()
  });
});
```

Phase 3: Real-time Frontend Updates

3.1 Add WebSocket Listener for Compression Updates
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Listen for compression completion events
- Automatically refresh when compression completes
- Handle multiple video players on same page

Code to add:
```typescript
// Add WebSocket listener
useEffect(() => {
  if (!fileId) return;

  const handleCompressionUpdate = (data: any) => {
    if (data.fileId === fileId) {
      console.log('🎬 Received compression update via WebSocket:', data);
      handleCompressionComplete();
    }
  };

  // Listen for compression updates
  const socket = io(); // Assuming you have socket connection
  socket.on('video-compression-update', handleCompressionUpdate);

  return () => {
    socket.off('video-compression-update', handleCompressionUpdate);
  };
}, [fileId, handleCompressionComplete]);
```

3.2 Add Global Compression Status Manager
File: frontend/src/hooks/useGlobalCompressionStatus.ts (new file)

Changes:
- Create global hook for managing compression status across components
- Prevent duplicate refresh calls
- Centralize compression completion logic

Code to create:
```typescript
import { useState, useCallback } from 'react';
import { io } from 'socket.io-client';

interface CompressionUpdate {
  fileId: string;
  compressedQualities: string[];
  timestamp: number;
}

export const useGlobalCompressionStatus = () => {
  const [completedCompressions, setCompletedCompressions] = useState<Set<string>>(new Set());
  const [callbacks, setCallbacks] = useState<Map<string, () => void>>(new Map());

  const registerCallback = useCallback((fileId: string, callback: () => void) => {
    setCallbacks(prev => new Map(prev).set(fileId, callback));
  }, []);

  const unregisterCallback = useCallback((fileId: string) => {
    setCallbacks(prev => {
      const newMap = new Map(prev);
      newMap.delete(fileId);
      return newMap;
    });
  }, []);

  // Listen for compression updates
  useEffect(() => {
    const socket = io();
    
    const handleCompressionUpdate = (data: CompressionUpdate) => {
      if (!completedCompressions.has(data.fileId)) {
        setCompletedCompressions(prev => new Set(prev).add(data.fileId));
        
        const callback = callbacks.get(data.fileId);
        if (callback) {
          callback();
        }
      }
    };

    socket.on('video-compression-update', handleCompressionUpdate);

    return () => {
      socket.off('video-compression-update', handleCompressionUpdate);
    };
  }, [callbacks, completedCompressions]);

  return {
    registerCallback,
    unregisterCallback,
    completedCompressions
  };
};
```

Phase 4: Enhanced User Experience

4.1 Add Compression Progress Indicator
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Show compression progress in video player
- Display estimated time remaining
- Add quality availability indicators

Code to add:
```typescript
// Add compression progress display
const renderCompressionStatus = () => {
  if (compressionStatus === 'compressing') {
    return (
      <div className="absolute top-4 right-4 bg-blue-500 text-white px-3 py-1 rounded-lg text-sm">
        <div className="flex items-center gap-2">
          <div className="animate-spin w-4 h-4 border-2 border-white border-t-transparent rounded-full"></div>
          Compressing video...
        </div>
      </div>
    );
  }
  
  if (isRefreshingQualities) {
    return (
      <div className="absolute top-4 right-4 bg-green-500 text-white px-3 py-1 rounded-lg text-sm">
        <div className="flex items-center gap-2">
          <div className="animate-spin w-4 h-4 border-2 border-white border-t-transparent rounded-full"></div>
          Updating qualities...
        </div>
      </div>
    );
  }
  
  if (compressionJustCompleted) {
    return (
      <div className="absolute top-4 right-4 bg-green-500 text-white px-3 py-1 rounded-lg text-sm animate-pulse">
        ✓ New qualities available!
      </div>
    );
  }
  
  return null;
};

// Add to video player JSX
{renderCompressionStatus()}
```

4.2 Add Quality Availability Indicators
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Show which qualities are available vs pending
- Add visual indicators for compression status
- Improve quality selector UI

Code to add:
```typescript
// Enhanced quality selector with availability indicators
const renderQualitySelector = () => {
  return (
    <div className="absolute bottom-4 right-4 bg-black bg-opacity-75 text-white p-2 rounded-lg">
      <div className="text-xs mb-1">Quality:</div>
      <div className="flex gap-1">
        {availableQualities.map((quality) => {
          const isAvailable = compressedQualities.includes(quality.name);
          const isCompressing = compressionStatus === 'compressing';
          
          return (
            <button
              key={quality.name}
              onClick={() => handleQualityChange(quality.name)}
              className={`px-2 py-1 text-xs rounded ${
                currentQuality === quality.name
                  ? 'bg-blue-500'
                  : isAvailable
                  ? 'bg-gray-600 hover:bg-gray-500'
                  : 'bg-gray-800 text-gray-400 cursor-not-allowed'
              }`}
              disabled={!isAvailable && quality.name !== 'original'}
              title={
                !isAvailable && quality.name !== 'original'
                  ? isCompressing
                    ? 'Compressing...'
                    : 'Not available'
                  : `Switch to ${quality.label}`
              }
            >
              {quality.label}
              {!isAvailable && quality.name !== 'original' && (
                <span className="ml-1">
                  {isCompressing ? '⏳' : '❌'}
                </span>
              )}
            </button>
          );
        })}
      </div>
    </div>
  );
};
```

Phase 5: Error Handling & Fallbacks

5.1 Add Robust Error Handling
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Handle WebSocket connection failures
- Add retry logic for failed refreshes
- Graceful degradation when real-time updates fail

Code to add:
```typescript
const handleCompressionComplete = useCallback(() => {
  try {
    console.log('🎬 Compression completed, refreshing video qualities');
    setIsRefreshingQualities(true);
    setCompressionJustCompleted(true);
    
    // Show user notification
    toast.success('Video compression completed! New qualities are now available.', {
      duration: 4000,
      position: 'top-right'
    });
    
    // Refresh with retry logic
    const refreshWithRetry = async (retries = 3) => {
      try {
        await optimizeVideoSource();
        setIsRefreshingQualities(false);
        setCompressionJustCompleted(false);
      } catch (error) {
        if (retries > 0) {
          console.warn(`Refresh failed, retrying... (${retries} attempts left)`);
          setTimeout(() => refreshWithRetry(retries - 1), 2000);
        } else {
          console.error('Failed to refresh video qualities after multiple attempts');
          setIsRefreshingQualities(false);
          setCompressionJustCompleted(false);
          toast.error('Failed to load new video qualities. Please refresh the page.');
        }
      }
    };
    
    setTimeout(() => refreshWithRetry(), 1000);
  } catch (error) {
    console.error('Error handling compression completion:', error);
    setIsRefreshingQualities(false);
    setCompressionJustCompleted(false);
  }
}, []);
```

5.2 Add Fallback Polling
File: frontend/src/hooks/useVideoCompressionStatus.ts

Changes:
- Add fallback polling when WebSocket fails
- Ensure compression completion is detected even without real-time updates

Code to add:
```typescript
// Add fallback polling for compression status
useEffect(() => {
  if (status.compressionStatus === 'compressing') {
    const interval = setInterval(checkStatus, 2000); // Check every 2 seconds
    return () => clearInterval(interval);
  }
}, [status.compressionStatus]);

// Add timeout for compression completion detection
useEffect(() => {
  if (status.compressionStatus === 'compressing') {
    const timeout = setTimeout(() => {
      console.warn('Compression taking longer than expected, checking status...');
      checkStatus();
    }, 30000); // Check after 30 seconds if still compressing
    
    return () => clearTimeout(timeout);
  }
}, [status.compressionStatus]);
```

Phase 6: Testing & Validation

6.1 Test Scenarios
1. **Normal compression completion**: Video compresses and automatically refreshes
2. **WebSocket failure**: Fallback polling detects completion
3. **Multiple video players**: Only relevant player refreshes
4. **Slow compression**: Progress indicators work correctly
5. **Compression failure**: Error handling works properly
6. **Network issues**: Retry logic functions correctly

6.2 Performance Considerations
- WebSocket events should be lightweight
- Avoid excessive polling when WebSocket is available
- Debounce refresh calls to prevent multiple simultaneous requests
- Cache compression status to avoid redundant API calls

Implementation Priority
1. **Phase 1**: Frontend compression status monitoring (Critical)
2. **Phase 2**: Backend WebSocket events (Critical)
3. **Phase 3**: Real-time frontend updates (Important)
4. **Phase 4**: Enhanced user experience (Important)
5. **Phase 5**: Error handling & fallbacks (Important)
6. **Phase 6**: Testing & validation (Essential)

Files to Modify (Priority Order)
1. frontend/src/hooks/useVideoCompressionStatus.ts (Critical)
2. frontend/src/components/VideoPlayer.tsx (Critical)
3. backend/src/services/video-compression.service.ts (Critical)
4. backend/src/socket/socketManager.ts (Important)
5. frontend/src/hooks/useGlobalCompressionStatus.ts (Important - new file)

This plan ensures users get seamless access to compressed video qualities without manual intervention, while maintaining robust error handling and fallback mechanisms.

