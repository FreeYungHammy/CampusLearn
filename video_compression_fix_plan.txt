Video Compression Status Fix - Implementation Plan

Problem Summary
The video player is trying to load compressed video qualities (480p, 720p) but getting 404 errors because those compressed versions don't exist. The system has inconsistent handling of compression status and file availability.

Root Issues Identified
1. Frontend tries to load compressed qualities without checking if they actually exist
2. Backend returns 404s for non-existent compressed files instead of graceful fallback
3. Compression status in database may not match actual file existence in GCS
4. No validation that compressed files actually exist before serving them

Implementation Plan

Phase 1: Backend Validation & Error Handling

1.1 Fix VideoCompressionService.getBestQualityUrl()
File: backend/src/services/video-compression.service.ts

Changes:
- Add file existence verification before returning compressed URLs
- Return original object name if compressed version doesn't exist
- Improve logging for debugging

Code to add in getBestQualityUrl method, around line 312:
// After finding the compressed name, verify it exists:
const [exists] = await bucket.file(compressedName).exists();
if (!exists) {
  logger.warn(`âŒ Compressed file ${compressedName} does not exist, falling back to original`);
  return originalObjectName;
}

1.2 Improve File Controller Error Responses
File: backend/src/modules/files/file.controller.ts

Changes:
- Return more informative error responses with available qualities
- Add proper fallback logic when compressed files don't exist
- Ensure consistent error handling across all controller variants

Code to modify around line 440:
return res.status(404).json({
  message: `Video quality ${requestedQuality} not available.`,
  availableQualities: item.compressedQualities || [],
  compressionStatus: item.compressionStatus,
  fallbackToOriginal: true
});

1.3 Add Compression Status Validation Endpoint
File: backend/src/modules/files/file.controller.ts

Changes:
- Add new endpoint to validate compression status against actual files
- Allow manual re-triggering of compression if needed

Add new method to FileController:
validateCompression: async (req: AuthedRequest, res: Response, next: NextFunction) => {
  // Implementation to check if compressed files actually exist
  // and update database status accordingly
}

Phase 2: Frontend Quality Management

2.1 Fix VideoPlayer Quality Selection Logic
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Only show quality options that are actually available
- Check compression status before attempting to load compressed versions
- Improve error handling and fallback logic

Code to modify around line 42:
const availableQualities = useMemo(() => {
  if (compressionStatus === 'completed' && compressedQualities.length > 0) {
    return compressedQualities.map(q => ({ name: q, label: q }));
  }
  return [{ name: 'original', label: 'Original' }];
}, [compressionStatus, compressedQualities]);

2.2 Update Quality Change Handler
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Add validation before attempting compressed quality loads
- Implement proper fallback to original video
- Add user feedback for unavailable qualities

Code to modify quality change logic:
const handleQualityChange = async (quality: string) => {
  if (quality === 'original' || !compressedQualities.includes(quality)) {
    setOptimizedSrc(src);
    return;
  }
  // Only try compressed version if it's confirmed available
  // ... existing logic
};

Phase 3: Database Schema Consistency

3.1 Ensure Compression Fields Are Optional
File: backend/src/schemas/tutorUpload.schema.ts

Changes:
- Make compression fields truly optional (not just default values)
- Add validation that compression fields only exist for video files

Code to modify schema:
const FileSchema = new Schema({
  // ... existing fields
  compressionStatus: { 
    type: String, 
    enum: ["pending", "compressing", "completed", "failed"], 
    default: undefined, // Remove default, make truly optional
    required: false
  },
  compressedQualities: { 
    type: [{ type: String }], 
    default: undefined, // Remove default, make truly optional
    required: false 
  },
}, { timestamps: true });

3.2 Update File Service Creation Logic
File: backend/src/modules/files/file.service.ts

Changes:
- Only add compression fields for video files
- Ensure non-video files don't get compression fields

Code to modify around line 54:
const fileData: any = {
  tutorId: input.tutorId,
  subject: input.subject,
  subtopic: input.subtopic,
  title: input.title,
  description: input.description,
  size: input.file.buffer.length,
  contentType,
};

// Only add compression fields for videos
if (contentType.startsWith("video/")) {
  fileData.compressionStatus = "pending";
  fileData.compressedQualities = [];
}

Phase 4: Error Handling & User Experience

4.1 Add Compression Status Monitoring
File: frontend/src/hooks/useVideoCompressionStatus.ts

Changes:
- Add better error handling
- Implement retry logic for failed status checks
- Add validation that compressed qualities actually exist

Code to add validation method:
const validateCompressedQualities = async () => {
  if (compressionStatus === 'completed' && compressedQualities.length > 0) {
    // Verify each quality actually exists by making HEAD requests
    // Update status if files don't exist
  }
};

4.2 Improve Video Player Error States
File: frontend/src/components/VideoPlayer.tsx

Changes:
- Add loading states for quality changes
- Show user-friendly messages when qualities aren't available
- Implement retry mechanisms

Phase 5: Testing & Validation

5.1 Test Cases to Implement
1. Video with completed compression: Should show available qualities
2. Video with failed compression: Should fallback to original
3. Video with compressing status: Should show loading state
4. Non-video files: Should never show quality options
5. Database/file mismatch: Should handle gracefully

5.2 Database Migration Considerations
- Existing files with compression fields but no actual compressed files
- Files with incorrect compression status
- Non-video files that incorrectly have compression fields

Phase 6: Monitoring & Logging

6.1 Add Comprehensive Logging
- Log when compressed files are requested but don't exist
- Track compression success/failure rates
- Monitor quality selection patterns

6.2 Add Health Check Endpoint
- Endpoint to verify compression system health
- Check for orphaned compression records
- Validate file existence vs database status

Critical Implementation Notes

Schema Consistency
- DO NOT remove compression fields from existing schema (breaks existing data)
- DO make them optional and only populate for videos
- DO add validation in service layer

Backward Compatibility
- All existing video files must continue to work
- Non-video files should not break if they have compression fields
- API responses must remain consistent

Error Handling Priority
1. Always fallback to original video if compressed version fails
2. Never break video playback due to compression issues
3. Provide clear user feedback about quality availability

Testing Strategy
1. Test with videos that have all qualities available
2. Test with videos that have partial compression
3. Test with videos that failed compression
4. Test with non-video files
5. Test with corrupted database records

Files to Modify (Priority Order)
1. backend/src/services/video-compression.service.ts (Critical)
2. backend/src/modules/files/file.controller.ts (Critical)
3. frontend/src/components/VideoPlayer.tsx (Critical)
4. backend/src/modules/files/file.service.ts (Important)
5. frontend/src/hooks/useVideoCompressionStatus.ts (Important)
6. backend/src/schemas/tutorUpload.schema.ts (Optional - only if making fields truly optional)

This plan ensures uniform handling across the entire system while maintaining backward compatibility and preventing any logic from breaking when compression data is missing or inconsistent.

